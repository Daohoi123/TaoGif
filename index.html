<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trình Tạo GIF Trước & Sau Hàng Loạt</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .sortable-ghost {
            opacity: 0.4;
            background: #c7d2fe;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 antialiased">

    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900">Trình Tạo GIF Hàng Loạt</h1>
            <p class="text-lg text-gray-600 mt-2">Tải lên nhiều cặp ảnh "trước & sau" để tạo hàng loạt GIF một cách hiệu quả!</p>
        </header>

        <main class="bg-white p-6 rounded-2xl shadow-lg">
            <!-- Phần Tải Lên Ảnh -->
            <section id="upload-section">
                <h2 class="text-2xl font-semibold mb-4 text-center">1. Tải Lên Các Cặp Ảnh</h2>
                <div class="bg-gray-50 p-6 rounded-lg border-2 border-dashed border-gray-300">
                    <p class="text-center text-gray-600 mb-4">Chọn các ảnh "TRƯỚC" và "SAU", sau đó sắp xếp, nhân đôi hoặc xóa để tạo các cặp ảnh mong muốn.</p>
                    <div class="flex flex-wrap justify-center gap-4">
                        <label for="before-imgs-input" class="flex items-center gap-2 bg-blue-500 text-white font-bold py-2 px-4 rounded-lg cursor-pointer hover:bg-blue-600 transition">
                            <i data-lucide="upload-cloud"></i>
                            <span>Thêm ảnh "TRƯỚC"</span>
                            <input type="file" id="before-imgs-input" accept="image/*" class="hidden" multiple>
                        </label>
                        <label for="after-imgs-input" class="flex items-center gap-2 bg-green-500 text-white font-bold py-2 px-4 rounded-lg cursor-pointer hover:bg-green-600 transition">
                            <i data-lucide="upload-cloud"></i>
                            <span>Thêm ảnh "SAU"</span>
                            <input type="file" id="after-imgs-input" accept="image/*" class="hidden" multiple>
                        </label>
                    </div>
                </div>
        
                <!-- Vùng xem trước và sắp xếp ảnh -->
                <div id="pairing-section" class="hidden mt-6">
                    <h3 class="text-xl font-semibold mb-3 text-center">Sắp xếp & Ghép cặp ảnh</h3>
                    <div id="pairing-alert" class="hidden p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50" role="alert">
                        <!-- Alert message goes here -->
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold text-center mb-2">Ảnh "TRƯỚC"</h4>
                            <div id="before-images-list" class="grid grid-cols-2 sm:grid-cols-3 gap-2 min-h-[150px] bg-gray-100 p-2 rounded-lg">
                                <!-- Before images will be here -->
                            </div>
                        </div>
                        <div>
                            <h4 class="font-semibold text-center mb-2">Ảnh "SAU"</h4>
                            <div id="after-images-list" class="grid grid-cols-2 sm:grid-cols-3 gap-2 min-h-[150px] bg-gray-100 p-2 rounded-lg">
                                <!-- After images will be here -->
                            </div>
                        </div>
                    </div>
                </div>
        
                <div class="text-center mt-6">
                    <button id="create-gif-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-transform transform hover:scale-105" disabled>
                        <span class="flex items-center justify-center">
                            <i data-lucide="film" class="mr-2 h-5 w-5"></i>
                            Tạo Tất Cả GIF
                        </span>
                    </button>
                </div>
            </section>
            
            <!-- Vùng Xem Trước & Loading -->
            <div id="loading-container" class="hidden flex-col items-center justify-center my-8 p-6 bg-gray-50 rounded-lg">
                <div class="loader"></div>
                <p class="mt-4 text-gray-600 font-semibold">Đang xử lý... Vui lòng đợi trong giây lát.</p>
            </div>
            
            <!-- Thư Viện GIF -->
            <section id="gallery-section" class="mt-12 hidden">
                <h2 class="text-2xl font-semibold mb-4 text-center">2. Thư Viện GIF Của Bạn</h2>
                <div id="gif-gallery" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                    <!-- Các GIF được tạo sẽ được thêm vào đây -->
                </div>
                <div class="text-center mt-8">
                    <button id="combine-gif-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-transform transform hover:scale-105" disabled>
                        <span class="flex items-center justify-center">
                            <i data-lucide="combine" class="mr-2 h-5 w-5"></i>
                            Nối Các GIF
                        </span>
                    </button>
                </div>
            </section>
        </main>
    </div>

    <!-- Modal Nối GIF -->
    <div id="combine-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold">Nối và Tùy Chỉnh GIF</h3>
                <button id="close-combine-modal" class="text-gray-500 hover:text-gray-800"><i data-lucide="x" class="h-8 w-8"></i></button>
            </div>
            <p class="text-gray-600 mb-4">Kéo và thả để sắp xếp thứ tự các GIF. Chúng sẽ được nối thành một file duy nhất.</p>
            <div id="combine-gif-list" class="flex-grow overflow-y-auto grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 bg-gray-100 p-4 rounded-lg min-h-[200px]">
                <!-- Danh sách GIF để sắp xếp -->
            </div>
            <div class="mt-6">
                <label for="aspect-ratio-select" class="block text-lg font-semibold mb-2">Chọn Khung Hình:</label>
                <select id="aspect-ratio-select" class="w-full p-3 border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="1/1" selected>Vuông (1x1)</option>
                    <option value="3/4">Dọc (3x4)</option>
                    <option value="4/3">Ngang (4x3)</option>
                </select>
            </div>
            <div class="mt-8 text-center">
                <button id="process-combine-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-purple-700 transition-transform transform hover:scale-105">
                    <span class="flex items-center justify-center">
                        <i data-lucide="wand-2" class="mr-2 h-5 w-5"></i>
                        Xử Lý & Tải Về
                    </span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Modal Tải Về & Chỉnh Sửa Chất Lượng -->
    <div id="download-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-lg">
             <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-bold">Tùy Chỉnh & Tải Về</h3>
                <button id="close-download-modal" class="text-gray-500 hover:text-gray-800"><i data-lucide="x" class="h-8 w-8"></i></button>
            </div>
            <div class="space-y-6">
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="speed-slider" class="font-semibold">Tốc độ (Thời gian)</label>
                        <span id="speed-value" class="text-blue-600 font-mono bg-blue-100 px-2 py-1 rounded">2.0s</span>
                    </div>
                    <input id="speed-slider" type="range" min="1" max="2" step="0.5" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="quality-slider" class="font-semibold">Chất lượng (Phân giải & Nén)</label>
                        <span id="quality-value" class="text-green-600 font-mono bg-green-100 px-2 py-1 rounded">100%</span>
                    </div>
                    <input id="quality-slider" type="range" min="50" max="100" step="10" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
            <div class="mt-8 text-center bg-gray-100 p-4 rounded-lg">
                <p class="text-lg font-semibold">Ước tính dung lượng file:</p>
                <p id="file-size-display" class="text-2xl font-bold text-gray-800 mt-1">--- KB</p>
            </div>
            <div class="mt-8 text-center">
                <button id="final-download-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 transition-transform transform hover:scale-105 w-full">
                    <span class="flex items-center justify-center">
                        <i data-lucide="download" class="mr-2 h-5 w-5"></i>
                        Tải Xuống GIF
                    </span>
                </button>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();

        const beforeImgsInput = document.getElementById('before-imgs-input');
        const afterImgsInput = document.getElementById('after-imgs-input');
        const pairingSection = document.getElementById('pairing-section');
        const pairingAlert = document.getElementById('pairing-alert');

        const createGifBtn = document.getElementById('create-gif-btn');
        const gallerySection = document.getElementById('gallery-section');
        const gifGallery = document.getElementById('gif-gallery');
        const combineGifBtn = document.getElementById('combine-gif-btn');
        const loadingContainer = document.getElementById('loading-container');
        
        const combineModal = document.getElementById('combine-modal');
        const closeCombineModalBtn = document.getElementById('close-combine-modal');
        const combineGifList = document.getElementById('combine-gif-list');
        const processCombineBtn = document.getElementById('process-combine-btn');
        const aspectRatioSelect = document.getElementById('aspect-ratio-select');

        const downloadModal = document.getElementById('download-modal');
        const closeDownloadModalBtn = document.getElementById('close-download-modal');
        const speedSlider = document.getElementById('speed-slider');
        const qualitySlider = document.getElementById('quality-slider');
        const speedValue = document.getElementById('speed-value');
        const qualityValue = document.getElementById('quality-value');
        const fileSizeDisplay = document.getElementById('file-size-display');
        const finalDownloadBtn = document.getElementById('final-download-btn');

        let beforeFiles = [];
        let afterFiles = [];
        let imagePairs = [];

        let gifCounter = 0;
        let createdGifs = [];
        let sortableCombineList = null;
        let currentGifDataForDownload = null;
        let gifWorkerUrl = null;
        let sortableBefore = null;
        let sortableAfter = null;

        async function getGifWorkerUrl() {
            if (gifWorkerUrl) return gifWorkerUrl;
            try {
                const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const scriptContent = await response.text();
                const blob = new Blob([scriptContent], { type: 'application/javascript' });
                gifWorkerUrl = URL.createObjectURL(blob);
                return gifWorkerUrl;
            } catch (error) {
                console.error('Could not fetch gif.worker.js.', error);
                return 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js';
            }
        }

        beforeImgsInput.addEventListener('change', handleFileSelection);
        afterImgsInput.addEventListener('change', handleFileSelection);

        function handleFileSelection(e) {
            const isBefore = e.target.id === 'before-imgs-input';
            const newFiles = Array.from(e.target.files);
            
            if (isBefore) {
                beforeFiles = beforeFiles.concat(newFiles);
            } else {
                afterFiles = afterFiles.concat(newFiles);
            }
            e.target.value = '';
            showPairingSection();
        }

        function showPairingSection() {
            pairingSection.classList.remove('hidden');
            renderImageLists();
            validateLists();
        }

        function renderImageLists() {
            const beforeList = document.getElementById('before-images-list');
            const afterList = document.getElementById('after-images-list');

            const renderList = (container, files, type) => {
                container.innerHTML = '';
                files.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'relative group border p-1 rounded-lg bg-white cursor-move shadow-sm';
                    item.dataset.index = index;
                    item.dataset.type = type;
                    const url = URL.createObjectURL(file);
                    item.innerHTML = `
                        <img src="${url}" class="w-full object-cover rounded-md aspect-square" draggable="false">
                        <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-60 transition-all duration-300 flex items-center justify-center gap-1 rounded-md">
                            <button title="Nhân đôi" class="duplicate-btn p-1.5 bg-white/80 text-blue-600 rounded-full opacity-0 group-hover:opacity-100 transform group-hover:scale-110 transition-all duration-300">
                                <i data-lucide="copy" class="h-4 w-4 pointer-events-none"></i>
                            </button>
                            <button title="Xóa" class="delete-btn p-1.5 bg-white/80 text-red-600 rounded-full opacity-0 group-hover:opacity-100 transform group-hover:scale-110 transition-all duration-300">
                                <i data-lucide="x" class="h-4 w-4 pointer-events-none"></i>
                            </button>
                        </div>
                        <div class="absolute top-1 left-1 bg-black/50 text-white text-xs font-bold rounded-full h-5 w-5 flex items-center justify-center">${index + 1}</div>
                    `;
                    container.appendChild(item);
                });
            };

            renderList(beforeList, beforeFiles, 'before');
            renderList(afterList, afterFiles, 'after');
            lucide.createIcons();

            if (sortableBefore) sortableBefore.destroy();
            sortableBefore = new Sortable(beforeList, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: (evt) => {
                    const [reorderedItem] = beforeFiles.splice(evt.oldIndex, 1);
                    beforeFiles.splice(evt.newIndex, 0, reorderedItem);
                    renderImageLists();
                    validateLists();
                }
            });

            if (sortableAfter) sortableAfter.destroy();
            sortableAfter = new Sortable(afterList, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: (evt) => {
                    const [reorderedItem] = afterFiles.splice(evt.oldIndex, 1);
                    afterFiles.splice(evt.newIndex, 0, reorderedItem);
                    renderImageLists();
                    validateLists();
                }
            });
        }

        pairingSection.addEventListener('click', (e) => {
            const duplicateBtn = e.target.closest('.duplicate-btn');
            const deleteBtn = e.target.closest('.delete-btn');
            
            if (duplicateBtn) {
                const item = duplicateBtn.closest('[data-index]');
                const type = item.dataset.type;
                const index = parseInt(item.dataset.index);
                
                if (type === 'before') {
                    beforeFiles.splice(index + 1, 0, beforeFiles[index]);
                } else {
                    afterFiles.splice(index + 1, 0, afterFiles[index]);
                }
                renderImageLists();
                validateLists();
            }

            if (deleteBtn) {
                const item = deleteBtn.closest('[data-index]');
                const type = item.dataset.type;
                const index = parseInt(item.dataset.index);
                
                if (type === 'before') {
                    beforeFiles.splice(index, 1);
                } else {
                    afterFiles.splice(index, 1);
                }
                renderImageLists();
                validateLists();
            }
        });

        function validateLists() {
            const listsAreEmpty = beforeFiles.length === 0 && afterFiles.length === 0;
            const listsMatch = beforeFiles.length === afterFiles.length && beforeFiles.length > 0;

            if (listsAreEmpty) {
                pairingSection.classList.add('hidden');
            }
            
            createGifBtn.disabled = !listsMatch;
            
            // Hide alert during arrangement, will only show on button click if there's an error.
            pairingAlert.classList.add('hidden');
        }
        
        createGifBtn.addEventListener('click', async () => {
            // Check for mismatch only when the create button is clicked
            if (beforeFiles.length !== afterFiles.length) {
                pairingAlert.innerHTML = `<span class="font-medium">Lỗi!</span> Số lượng ảnh "TRƯỚC" (${beforeFiles.length}) và "SAU" (${afterFiles.length}) không khớp. Vui lòng điều chỉnh lại.`;
                pairingAlert.classList.remove('hidden');
                return; // Stop execution
            }

            imagePairs = [];
            for (let i = 0; i < beforeFiles.length; i++) {
                imagePairs.push({ before: beforeFiles[i], after: afterFiles[i] });
            }

            loadingContainer.classList.remove('hidden');
            loadingContainer.classList.add('flex');
            const loadingText = loadingContainer.querySelector('p');
            createGifBtn.disabled = true;

            for (let i = 0; i < imagePairs.length; i++) {
                const pair = imagePairs[i];
                try {
                    loadingText.textContent = `Đang xử lý cặp ${i + 1} / ${imagePairs.length}... Vui lòng đợi.`;
                    const gifData = await generateGif(pair.before, pair.after, 2, 100);
                    addGifToGallery(gifData);
                } catch (error) {
                    console.error(`Error creating GIF for pair ${i + 1}:`, error);
                    alert(`Đã xảy ra lỗi khi tạo GIF cho cặp ${i + 1}.`);
                }
            }

            loadingText.textContent = 'Đang xử lý... Vui lòng đợi trong giây lát.';
            loadingContainer.classList.add('hidden');
            loadingContainer.classList.remove('flex');
            
            beforeFiles = [];
            afterFiles = [];
            imagePairs = [];
            showPairingSection();
        });
        
        // NEW: Function to compress image before processing
        function compressAndLoadImage(file, quality) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    const jpegQuality = quality / 100;
                    const dataUrl = canvas.toDataURL('image/jpeg', jpegQuality);
                    
                    const compressedImg = new Image();
                    compressedImg.onload = () => resolve(compressedImg);
                    compressedImg.onerror = reject;
                    compressedImg.src = dataUrl;
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }
        
        // UPDATED: generateGif to use new compression
        async function generateGif(beforeFile, afterFile, durationSec, quality) {
             return new Promise(async (resolve, reject) => {
                const [beforeImage, afterImage] = await Promise.all([
                    compressAndLoadImage(beforeFile, quality),
                    compressAndLoadImage(afterFile, quality)
                ]);

                const baseWidth = beforeImage.naturalWidth;
                const baseHeight = beforeImage.naturalHeight;
                const scale = quality / 100; // Also scale down resolution
                const width = Math.round(baseWidth * scale);
                const height = Math.round(baseHeight * scale);
                const gifJsQuality = Math.max(1, Math.round(10 + ((100 - quality) / 50) * 20));
                
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const frameDelay = 1000 / 30;
                const totalFrames = durationSec * 30;
                const workerScriptUrl = await getGifWorkerUrl();
                const gif = new GIF({ workers: 2, quality: gifJsQuality, width: width, height: height, workerScript: workerScriptUrl });

                for (let i = 0; i <= totalFrames; i++) {
                    const progress = i / totalFrames;
                    ctx.clearRect(0, 0, width, height);
                    ctx.drawImage(beforeImage, 0, 0, width, height);
                    ctx.drawImage(afterImage, 0, 0, afterImage.naturalWidth * progress, afterImage.naturalHeight, 0, 0, width * progress, height);
                    gif.addFrame(ctx, { copy: true, delay: frameDelay });
                }

                gif.on('finished', (blob) => resolve({ blob, id: `gif-${gifCounter}`, beforeFile, afterFile }));
                gif.on('abort', () => reject('GIF creation aborted'));
                gif.render();
            });
        }
        
        function addGifToGallery(gifData) {
            gifCounter++;
            gallerySection.classList.remove('hidden');
            const gifUrl = URL.createObjectURL(gifData.blob);
            const container = document.createElement('div');
            container.className = 'relative group border-2 border-gray-200 rounded-lg p-2 bg-white';
            container.dataset.id = gifData.id;
            container.innerHTML = `
                <img src="${gifUrl}" class="w-full h-auto object-cover rounded-md">
                <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-50 transition-all duration-300 flex items-center justify-center gap-2 rounded-lg">
                    <button title="Tải xuống GIF này" class="download-one p-2 bg-white text-blue-600 rounded-full opacity-0 group-hover:opacity-100 transform group-hover:scale-110 transition-all duration-300">
                        <i data-lucide="download" class="h-6 w-6"></i>
                    </button>
                    <button title="Xóa GIF này" class="delete-one p-2 bg-white text-red-600 rounded-full opacity-0 group-hover:opacity-100 transform group-hover:scale-110 transition-all duration-300">
                        <i data-lucide="x" class="h-6 w-6"></i>
                    </button>
                </div>`;
            container.querySelector('.download-one').onclick = () => openDownloadModal(gifData);
            container.querySelector('.delete-one').onclick = (e) => { e.stopPropagation(); deleteGif(gifData.id); };
            gifGallery.appendChild(container);
            lucide.createIcons();
            createdGifs.push(gifData);
            combineGifBtn.disabled = createdGifs.length < 1;
        }

        function deleteGif(gifId) {
            createdGifs = createdGifs.filter(gif => gif.id !== gifId);
            const gifElement = gifGallery.querySelector(`[data-id="${gifId}"]`);
            if (gifElement) gifElement.remove();
            combineGifBtn.disabled = createdGifs.length < 1;
            if (createdGifs.length === 0) gallerySection.classList.add('hidden');
        }

        function openDownloadModal(gifData) {
            currentGifDataForDownload = gifData;
            if(currentGifDataForDownload.isCombined) {
                const duration = currentGifDataForDownload.duration;
                speedSlider.max = duration;
                speedSlider.value = duration;
                speedSlider.min = duration * 0.5;
                speedValue.textContent = `${duration.toFixed(1)}s`;
            } else {
                 speedSlider.max = 4; speedSlider.min = 0.5; speedSlider.step = 0.1; speedSlider.value = 2;
                 speedValue.textContent = '2.0s';
            }
            qualitySlider.value = 100;
            qualityValue.textContent = '100%';
            updateFileSize();
            downloadModal.classList.remove('hidden');
        }

        closeDownloadModalBtn.addEventListener('click', () => downloadModal.classList.add('hidden'));
        speedSlider.addEventListener('input', () => { speedValue.textContent = `${parseFloat(speedSlider.value).toFixed(1)}s`; updateFileSize(); });
        qualitySlider.addEventListener('input', () => { qualityValue.textContent = `${qualitySlider.value}%`; updateFileSize(); });

        let updateTimeout;
        function updateFileSize() {
            fileSizeDisplay.textContent = 'Đang tính toán...';
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(async () => {
                if (!currentGifDataForDownload) return;
                const duration = parseFloat(speedSlider.value);
                const quality = parseInt(qualitySlider.value);
                let gifBlob;
                if(currentGifDataForDownload.isCombined){
                    gifBlob = (await generateCombinedGif(currentGifDataForDownload.orderedGifs, currentGifDataForDownload.aspectRatio, duration, quality)).blob;
                } else {
                    gifBlob = (await generateGif(currentGifDataForDownload.beforeFile, currentGifDataForDownload.afterFile, duration, quality)).blob;
                }
                const sizeInKB = gifBlob.size / 1024;
                fileSizeDisplay.textContent = `${sizeInKB.toFixed(1)} KB`;
                finalDownloadBtn.onclick = () => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(gifBlob);
                    a.download = `${currentGifDataForDownload.id}_${duration}s_${quality}p.gif`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                };
            }, 500);
        }

        combineGifBtn.addEventListener('click', () => {
            combineGifList.innerHTML = '';
            createdGifs.forEach(gifData => {
                const item = document.createElement('div');
                item.className = 'p-1 border bg-white rounded cursor-move';
                item.dataset.id = gifData.id;
                const img = document.createElement('img');
                img.src = URL.createObjectURL(gifData.blob);
                img.className = 'w-full h-auto object-cover rounded-sm';
                item.appendChild(img);
                combineGifList.appendChild(item);
            });
            if (sortableCombineList) sortableCombineList.destroy();
            sortableCombineList = new Sortable(combineGifList, { animation: 150, ghostClass: 'sortable-ghost' });
            combineModal.classList.remove('hidden');
        });

        closeCombineModalBtn.addEventListener('click', () => combineModal.classList.add('hidden'));
        
        processCombineBtn.addEventListener('click', async () => {
            const orderedIds = [...combineGifList.children].map(child => child.dataset.id);
            const orderedGifs = orderedIds.map(id => createdGifs.find(g => g.id === id));
            const aspectRatio = aspectRatioSelect.value;
            const duration = orderedGifs.length * 2;
            openDownloadModal({ orderedGifs, aspectRatio, id: 'combined-gif', isCombined: true, duration: duration });
            combineModal.classList.add('hidden');
        });
        
        // UPDATED: generateCombinedGif to use new compression
        async function generateCombinedGif(gifsToCombine, aspectRatio, durationSec, quality) {
             return new Promise(async (resolve, reject) => {
                const [wRatio, hRatio] = aspectRatio.split('/').map(Number);
                const loadedImages = [];
                let maxWidth = 0;

                const compressionPromises = gifsToCombine.flatMap(gifData => [
                    compressAndLoadImage(gifData.beforeFile, quality),
                    compressAndLoadImage(gifData.afterFile, quality)
                ]);
                const compressedImages = await Promise.all(compressionPromises);

                for (let i = 0; i < compressedImages.length; i += 2) {
                    const before = compressedImages[i];
                    const after = compressedImages[i+1];
                    if (before.naturalWidth > maxWidth) maxWidth = before.naturalWidth;
                    loadedImages.push({ before, after });
                }

                const BASE_WIDTH_CAP = 800;
                const baseWidth = maxWidth > BASE_WIDTH_CAP ? BASE_WIDTH_CAP : maxWidth;
                const baseHeight = (baseWidth / wRatio) * hRatio;
                const scale = quality / 100;
                const canvasWidth = Math.round(baseWidth * scale);
                const canvasHeight = Math.round(baseHeight * scale);
                const gifJsQuality = Math.max(1, Math.round(10 + ((100 - quality) / 50) * 20));
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth; canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');
                const singleGifDuration = durationSec / gifsToCombine.length;
                const frameDelay = 1000 / 30;
                const framesPerGif = singleGifDuration * 30;
                const workerScriptUrl = await getGifWorkerUrl();
                const gif = new GIF({ workers: 2, quality: gifJsQuality, width: canvasWidth, height: canvasHeight, workerScript: workerScriptUrl });
                
                for (const { before: beforeImage, after: afterImage } of loadedImages) {
                    for (let j = 0; j < framesPerGif; j++) {
                        const progress = j / framesPerGif;
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                        const imgAspectRatio = beforeImage.naturalWidth / beforeImage.naturalHeight;
                        let drawWidth = canvasWidth, drawHeight = canvasWidth / imgAspectRatio;
                        if (drawHeight > canvasHeight) { drawHeight = canvasHeight; drawWidth = canvasHeight * imgAspectRatio; }
                        const x = (canvasWidth - drawWidth) / 2, y = (canvasHeight - drawHeight) / 2;
                        ctx.drawImage(beforeImage, x, y, drawWidth, drawHeight);
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(x, y, drawWidth * progress, drawHeight);
                        ctx.clip();
                        ctx.drawImage(afterImage, x, y, drawWidth, drawHeight);
                        ctx.restore();
                        gif.addFrame(ctx, { copy: true, delay: frameDelay });
                    }
                }
                gif.on('finished', (blob) => resolve({ blob }));
                gif.on('abort', () => reject('Combined GIF creation aborted'));
                gif.render();
            });
        }
    </script>
</body>
</html>

